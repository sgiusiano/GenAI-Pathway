import tempfile
from dataclasses import dataclass

import fitz

from licitaciones.config import get_settings


@dataclass
class PDFQualityReport:
    """Report containing PDF quality metrics for pipeline decision-making."""

    is_digital: bool
    quality_score: int  # 0-100 (100 = best quality)

    # Detailed metrics
    text_to_size_ratio: float
    image_coverage_ratio: float
    ocr_text_ratio: float
    low_res_image_count: int
    rotated_text_ratio: float
    pages_analyzed: int


class PDFProcessor:
    def __init__(self, settings=None):
        self.settings = settings or get_settings()

    def _check_pages_quantity(self, doc: fitz.Document) -> int:
        """Check page count and return it if valid, raise if exceeds limit."""
        num_pages = doc.page_count
        if num_pages > self.settings.pdf_max_pages:
            raise ValueError(
                f"PDF has {num_pages} pages, which exceeds the maximum allowed {self.settings.pdf_max_pages} pages."
            )
        return num_pages

    def _check_file_size(self, doc: fitz.Document) -> int:
        """Check file size and return bytes if valid, raise if exceeds limit."""
        file_size = len(doc.tobytes())
        file_size_mb = file_size / (1024 * 1024)
        if file_size_mb > self.settings.pdf_max_size_mb:
            raise ValueError(
                f"PDF size is {file_size_mb:.2f} MB, which exceeds the maximum allowed {self.settings.pdf_max_size_mb} MB."
            )
        return file_size

    def check_quality(self, pdf_path: str) -> PDFQualityReport:
        """Analyze PDF quality and return metrics for pipeline decision-making.

        Args:
            pdf_path: Path to the PDF file to analyze.

        Quality checks performed:
        1. Digital vs Scanned: Compares extracted text size to file size.
           Low ratio indicates scanned PDF (mostly images, little text).
        2. OCR Text Detection: Checks for "GlyphlessFont" which indicates
           text was generated by OCR. OCR text has higher error risk.
        3. Image Coverage: Calculates what % of pages are covered by images.
           High coverage suggests scanned PDF or image-heavy catalog.
        4. Low Resolution Images: Counts images below DPI threshold.
           Low-res images in scanned PDFs indicate poor scan quality.
        5. Rotated Text: Detects text with non-standard direction.
           Rotated text may cause extraction issues.

        Score calculation (0-100, higher = better quality):
        - Start at 100
        - -40 if not digital (scanned without extractable text)
        - -30 * ocr_text_ratio (proportional to OCR content)
        - -25 * image_coverage_ratio (proportional to image coverage)
        - -20 if any low resolution images found
        - -15 * rotated_text_ratio (proportional to rotated text)
        """
        with fitz.open(pdf_path) as doc:
            num_pages = self._check_pages_quantity(doc)
            file_size = self._check_file_size(doc)

            total_text = ""
            total_chars = 0
            ocr_chars = 0
            rotated_lines = 0
            total_lines = 0
            total_image_coverage = 0.0
            low_res_image_count = 0

            for page in doc:
                total_text += page.get_text()

                text_dict = page.get_text("dict")
                page_rect = page.rect
                page_area = page_rect.width * page_rect.height

                for block in text_dict.get("blocks", []):
                    if "lines" not in block:
                        continue

                    for line in block.get("lines", []):
                        total_lines += 1

                        # Normal text direction is (1, 0). Any other value means rotated.
                        direction = line.get("dir", (1, 0))
                        if direction != (1, 0):
                            rotated_lines += 1

                        for span in line.get("spans", []):
                            text = span.get("text", "")
                            total_chars += len(text)

                            # "GlyphlessFont" is used by fitz to mark OCR-generated text
                            if span.get("font") == "GlyphlessFont":
                                ocr_chars += len(text)

                images = page.get_images()
                page_image_area = 0.0

                for img in images:
                    xref = img[0]
                    try:
                        img_info = doc.extract_image(xref)
                        xres = img_info.get("xres", 0)
                        yres = img_info.get("yres", 0)
                        avg_dpi = (xres + yres) / 2 if xres and yres else 0

                        if 0 < avg_dpi < self.settings.pdf_low_res_dpi_threshold:
                            low_res_image_count += 1

                        # Calculate image area on page for coverage ratio
                        img_rects = page.get_image_rects(xref)
                        for rect in img_rects:
                            page_image_area += rect.width * rect.height
                    except Exception:
                        pass

                if page_area > 0:
                    total_image_coverage += page_image_area / page_area

            # Calculate quality metrics
            text_size = len(total_text.encode("utf-8"))
            text_to_size_ratio = text_size / file_size if file_size > 0 else 0
            image_coverage_ratio = total_image_coverage / num_pages if num_pages > 0 else 0
            ocr_text_ratio = ocr_chars / total_chars if total_chars > 0 else 0
            rotated_text_ratio = rotated_lines / total_lines if total_lines > 0 else 0

            # Digital = has enough extractable text relative to file size
            is_digital = text_to_size_ratio > self.settings.pdf_text_to_size_ratio_threshold

            # Calculate quality score with weighted penalties
            score = 100.0
            score -= 40 if not is_digital else 0  # Scanned PDF without text
            score -= 30 * ocr_text_ratio  # OCR text has error risk
            score -= 25 * image_coverage_ratio  # High image coverage = likely scanned
            score -= 20 if low_res_image_count > 0 else 0  # Low quality images
            score -= 15 * rotated_text_ratio  # Rotated text extraction issues
            quality_score = max(0, int(score))

            return PDFQualityReport(
                is_digital=is_digital,
                quality_score=quality_score,
                text_to_size_ratio=text_to_size_ratio,
                image_coverage_ratio=image_coverage_ratio,
                ocr_text_ratio=ocr_text_ratio,
                low_res_image_count=low_res_image_count,
                rotated_text_ratio=rotated_text_ratio,
                pages_analyzed=num_pages,
            )

    def extract_pages(self, pdf_path: str, page_ranges: list[tuple[int, int]]) -> str:
        """Extract multiple page ranges from PDF and save to temp file.

        Args:
            pdf_path: Source PDF path.
            page_ranges: List of (start, end) tuples, 1-indexed, inclusive.
                If end exceeds document pages, it clips to the last page.

        Returns:
            Path to temporary PDF with selected pages.
        """
        with fitz.open(pdf_path) as doc:
            total_pages = doc.page_count
            new_doc = fitz.open()

            for start, end in page_ranges:
                # Clip end to actual page count
                clipped_end = min(end, total_pages)

                # Skip range if start exceeds total pages
                if start > total_pages:
                    continue

                # fitz uses 0-indexed pages
                new_doc.insert_pdf(doc, from_page=start - 1, to_page=clipped_end - 1)

            if new_doc.page_count == 0:
                new_doc.close()
                raise ValueError(
                    f"No valid pages to extract. PDF has {total_pages} pages, "
                    f"but requested ranges {page_ranges} are out of bounds."
                )

            temp_file = tempfile.NamedTemporaryFile(suffix=".pdf", delete=False)
            new_doc.save(temp_file.name)
            new_doc.close()
            return temp_file.name
